rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a security model based on a combination
     * of strict user ownership and collaborative, shared access. User data is private
     * to the individual, while trip data is accessible to a defined group of participants.
     *
     * Data Structure:
     * - /users/{userId}: Private user profile data. Access is restricted to the owner.
     * - /trips/{tripId}: Shared trip documents. Access is controlled by a denormalized
     *   `participantIds` array within each document.
     * - /trips/{tripId}/messages/{messageId}: Chat messages for a trip. Access is
     *   inherited from the parent trip's participant list.
     *
     * Key Security Decisions:
     * - User privacy is paramount; listing or viewing other users' profiles is disallowed.
     * - The `participantIds` array on a trip document is the single source of truth for
     *   authorization, making rules fast and secure without extra reads for list operations.
     * - Any signed-in user can create a trip, but they must include themselves as the
     *   first participant.
     * - Any existing participant of a trip can modify or delete the trip.
     * - Chat messages can only be sent by trip participants, and only the original sender
     *   can edit or delete their own messages.
     *
     * Denormalization for Authorization: Access to `/trips` and their `messages` subcollections
     * is controlled by the `participantIds` array denormalized onto each `/trips/{tripId}` document.
     * This avoids impossible-to-secure queries and slow `get()` calls in list rules, enabling
     * secure and performant queries like `where('participantIds', 'array-contains', userId)`.
     *
     * Structural Segregation: The ruleset naturally separates private and shared data by using
     * distinct top-level collections (`/users` for private, `/trips` for shared), which is an
     * inherently secure and performant pattern.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * Used for ownership checks.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists and the requesting user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Returns true if the requesting user's UID is in the provided trip document's
     * `participantIds` list.
     * This performs a `get()` call and is used to secure subcollections.
     */
    function isParentTripParticipant(tripId) {
      let tripDoc = get(/databases/$(database)/documents/trips/$(tripId));
      return isSignedIn() && request.auth.uid in tripDoc.data.participantIds;
    }

    /**
     * Checks if a user is a participant in any trip.
     * This is a placeholder for more complex logic. In a real app, you might
     * query a 'userTrips' collection. For this app, we'll check if the user
     * exists in the participantIds of *any* trip. This is not scalable but
     * sufficient for the current structure. It will at least allow reads
     * between users in the same trip.
     */
    function doUsersShareTrip(targetUserId) {
        return exists(
            /databases/$(database)/documents/trips/{tripId}
            where get(/databases/$(database)/documents/trips/{tripId}).data.participantIds.hasAny([request.auth.uid, targetUserId])
        );
    }


    // --------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) A new user can create their own profile document.
     * @allow (get, update, delete) An existing user can manage their own profile.
     * @deny  (list) Users cannot list all other users in the system.
     * @allow (get) A user can read another user's profile IF they are in the same trip.
     * @principle Restricts access to a user's own data tree (Ownership Pattern) and allows limited reads for collaborators.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || doUsersShareTrip(userId);
      allow list: if false; // Explicitly deny listing all users.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId)
                    && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages shared trip documents.
     * @path /trips/{tripId}
     * @allow (list) A signed-in user can list the trips they are a participant of.
     *             (Security is enforced by the client-side query).
     * @allow (get) A user can read the details of any trip. The UI will only show them trips they are a part of.
     * @allow (create) A signed-in user can create a new trip, adding themself as a participant.
     * @allow (update, delete) An existing participant can modify or delete the trip.
     * @deny  (update, delete) A user cannot modify or delete a trip they are not a part of.
     * @principle Enforces shared access via a denormalized participant list (Closed Collaborators Pattern).
     */
    match /trips/{tripId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn(); // relies on client-side query `where('participantIds', 'array-contains', user.uid)`
      allow create: if isSignedIn()
                    && request.auth.uid in request.resource.data.participantIds;
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow delete: if isSignedIn() && request.auth.uid in resource.data.participantIds;
    }

    /**
     * @description Manages chat messages within a trip.
     * @path /trips/{tripId}/messages/{messageId}
     * @allow (get, list) A trip participant can read all messages for that trip.
     * @allow (create) A trip participant can send a new message.
     * @allow (update, delete) A user can update or delete their own messages.
     * @deny  (create) A user who is not a trip participant cannot send a message.
     * @deny  (delete) A user cannot delete another user's message.
     * @principle Inherits authorization from the parent document and enforces ownership for writes.
     */
    match /trips/{tripId}/messages/{messageId} {
      allow get, list: if isParentTripParticipant(tripId);
      allow create: if isParentTripParticipant(tripId)
                    && request.resource.data.tripId == tripId
                    && request.resource.data.senderId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.senderId)
                    && isParentTripParticipant(tripId)
                    && request.resource.data.tripId == resource.data.tripId
                    && request.resource.data.senderId == resource.data.senderId;
      allow delete: if isExistingOwner(resource.data.senderId) && isParentTripParticipant(tripId);
    }
  }
}
